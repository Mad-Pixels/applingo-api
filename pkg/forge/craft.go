package forge

import (
	"bytes"
	"context"
	"errors"
	"io"
	"sync"

	"github.com/Mad-Pixels/applingo-api/lingo-interface/types"
	"github.com/Mad-Pixels/applingo-api/pkg/chatgpt"
	"github.com/Mad-Pixels/applingo-api/pkg/cloud"
	"github.com/Mad-Pixels/applingo-api/pkg/utils"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/google/uuid"
)

// DictionaryMetaFromAI represents metadata about the dictionary generated by the AI.
// It includes a description, the author, and the name of the dictionary.
type DictionaryMetaFromAI struct {
	Description string `json:"description"`
	Author      string `json:"author"`
	Name        string `json:"name"`
}

// DictionaryWordFromAI represents a single word entry in the generated dictionary.
// It includes the word itself, its translation, a description, and an optional hint.
type DictionaryWordFromAI struct {
	Description string `json:"description"`
	Translation string `json:"translation"`
	Word        string `json:"word"`
	Hint        string `json:"hint"`
}

// ResponseDictionaryCraft represents the complete response payload for a dictionary generation request.
// It includes the generated dictionary metadata, a list of dictionary words, and the original request parameters.
type ResponseDictionaryCraft struct {
	Meta    DictionaryMetaFromAI    `json:"meta"`
	Words   []DictionaryWordFromAI  `json:"words"`
	Request *RequestDictionaryCraft `json:"request"`
}

// RequestDictionaryCraft represents a request payload for generating a dictionary using OpenAI.
// It includes details such as the prompt template key, model, file information, topic, description, language settings,
// and additional parameters controlling the generation process.
type RequestDictionaryCraft struct {
	aiModel chatgpt.OpenAIModel

	// Prompt is the S3 key (without prefix, only the prompt name) for the prompt template.
	Prompt *string `json:"prompt"`
	// Model is the user-provided OpenAI model name, which may be invalid.
	Model *string `json:"model"`
	// DictionaryFile is the S3 key for the dictionary file; the file will be created using this name.
	DictionaryFile *string `json:"file"`
	// DictionaryTopic specifies the topic used by OpenAI to generate the dictionary.
	DictionaryTopic *string `json:"topic"`
	// DictionaryDescription provides additional description to guide OpenAI in generating the dictionary.
	DictionaryDescription *string `json:"description"`
	// LanguageLevel indicates the proficiency level (e.g., A1, B2) for the dictionary words.
	LanguageLevel *string `json:"level"`
	// LanguageFrom indicates the source language.
	LanguageFrom *string `json:"from"`
	// LanguageTo indicates the target language.
	LanguageTo *string `json:"to"`

	// Temperature controls the randomness of the generated content.
	Temperature float64 `json:"temperature"`
	// WordsCount specifies the number of words to include in the generated dictionary.
	WordsCount int `json:"count"`

	// promptBuf is an internal buffer to hold the fetched prompt template data.
	promptBuf *bytes.Buffer
}

// NewRequestDictionaryCraft creates a new RequestDictionaryCraft with initialized buffers.
func NewRequestDictionaryCraft() *RequestDictionaryCraft {
	return &RequestDictionaryCraft{
		promptBuf: &bytes.Buffer{},
	}
}

// GetModel returns the model.
func (r *RequestDictionaryCraft) GetModel() chatgpt.OpenAIModel {
	return r.aiModel
}

// GetPromptBody returns an io.Reader with prompt content.
func (r *RequestDictionaryCraft) GetPromptBody() io.Reader {
	return r.promptBuf
}

// Setup prepares the request and create a prompt for OpenAI or return error.
func (r *RequestDictionaryCraft) Setup(ctx context.Context, s3cli *cloud.Bucket, promptBucketName string) error {
	var (
		results  = make(chan workerResult, 2)
		setupErr error
		wg       sync.WaitGroup
	)

	// Operation for getting prompt name, model name, temperature for openai request.
	runWorker(ctx, &wg, results, "openai", func() error {
		// checking prompt.
		if r.Prompt == nil {
			prompt, err := s3cli.GetRandomKey(ctx, promptBucketName, craftPromptPrefix)
			if err != nil {
				return errors.Join(ErrorGetKeyFromBucket(craftPromptPrefix, promptBucketName), err)
			}
			r.Prompt = &prompt
		}

		// checking openai model.
		if r.Model == nil {
			model := string(defaultModel)
			r.Model = &model
			r.aiModel = defaultModel
		} else {
			model, err := chatgpt.ParseModel(aws.ToString(r.Model))
			if err != nil {
				return errors.Join(ErrorOpenAIModelNotSupported(aws.ToString(r.Model)), err)
			}
			r.aiModel = model
		}

		// checking temperature.
		if r.Temperature < 0.2 || r.Temperature > 0.9 {
			r.Temperature = defaultTemperature
		}
		return nil
	})

	// Operation for getting static data for craft dictionary prompt template.
	runWorker(ctx, &wg, results, "static", func() error {
		// checking words count.
		if r.WordsCount < 1 || r.WordsCount > dictionaryMaxLength {
			count, err := utils.RandomInt(dictionaryMinLength, dictionaryMaxLength)
			if err != nil {
				return errors.Join(ErrorGenerateRandomInt(dictionaryMinLength, dictionaryMaxLength), err)
			}
			r.WordsCount = count
		}

		// checking dictionary file name.
		if r.DictionaryFile == nil {
			name := uuid.NewString()
			r.DictionaryFile = &name
		}

		// checking dictionary topic.
		if r.DictionaryTopic == nil {
			topic, err := types.GetRandomDictionaryTopic()
			if err != nil {
				return errors.Join(ErrorGenerateDictionaryTopic, err)
			}
			topicStr := topic.String()
			r.DictionaryTopic = &topicStr
		}

		// checking dictionary description.
		if r.DictionaryDescription == nil {
			description, err := types.GetRandomDictionaryDescription()
			if err != nil {
				return errors.Join(ErrorGenerateDictionaryDescription, err)
			}
			descriptionStr := description.String()
			r.DictionaryDescription = &descriptionStr
		}

		// checking language level.
		if r.LanguageLevel == nil {
			level, err := types.GetRandomLanguageLevel()
			if err != nil {
				return errors.Join(ErrorGenerateLanguageLevel, err)
			}
			levelStr := level.String()
			r.LanguageLevel = &levelStr
		} else {
			_, err := types.ParseLanguageLevel(*r.LanguageLevel)
			if err != nil {
				level, randErr := types.GetRandomLanguageLevel()
				if randErr != nil {
					return errors.Join(ErrorGenerateLanguageLevel, randErr)
				}
				levelStr := level.String()
				r.LanguageLevel = &levelStr
			}
		}

		// checking LanguageFrom.
		if r.LanguageFrom == nil {
			langCode, err := types.GetRandomLanguageCode()
			if err != nil {
				return errors.Join(ErrorGenerateLanguage("from"), err)
			}
			langName := langCode.Name()
			r.LanguageFrom = &langName
		} else if len(*r.LanguageFrom) == 2 {
			langCode, err := types.ParseLanguageCode(*r.LanguageFrom)
			if err != nil {
				return errors.Join(ErrorInvalidLanguageCode(*r.LanguageFrom), err)
			}
			langName := langCode.Name()
			r.LanguageFrom = &langName
		}

		// checking LanguageTo.
		if r.LanguageTo == nil {
			allLangs := types.AllLanguageCodes()
			validLangs := make([]types.LanguageCode, 0, len(allLangs)-1)

			for _, code := range allLangs {
				if code.Name() != *r.LanguageFrom {
					validLangs = append(validLangs, code)
				}
			}

			if len(validLangs) == 0 {
				return errors.New("no valid target languages available")
			}

			idx, err := utils.RandomInt(0, len(validLangs)-1)
			if err != nil {
				return errors.Join(ErrorGenerateLanguage("to"), err)
			}

			langName := validLangs[idx].Name()
			r.LanguageTo = &langName
		} else if len(*r.LanguageTo) == 2 {
			langCode, err := types.ParseLanguageCode(*r.LanguageTo)
			if err != nil {
				return errors.Join(ErrorInvalidLanguageCode(*r.LanguageTo), err)
			}
			langName := langCode.Name()
			r.LanguageTo = &langName
		}

		// checking that langs are different.
		if *r.LanguageFrom == *r.LanguageTo {
			allLangs := types.AllLanguageCodes()
			validLangs := make([]types.LanguageCode, 0, len(allLangs)-1)

			for _, code := range allLangs {
				if code.Name() != *r.LanguageFrom {
					validLangs = append(validLangs, code)
				}
			}
			if len(validLangs) == 0 {
				return errors.New("no valid target languages available")
			}
			idx, err := utils.RandomInt(0, len(validLangs)-1)
			if err != nil {
				return errors.Join(ErrorGenerateLanguage("to"), err)
			}

			langName := validLangs[idx].Name()
			r.LanguageTo = &langName
		}
		return nil
	})

	go func() {
		wg.Wait()
		close(results)
	}()
	for res := range results {
		if res.error != nil {
			workerErr := errors.Join(ErrorWorkerProcess(res.key), res.error)
			if setupErr == nil {
				setupErr = workerErr
			} else {
				setupErr = errors.Join(setupErr, workerErr)
			}
		}
	}
	if setupErr != nil {
		return errors.Join(ErrorSetupProcess, setupErr)
	}

	select {
	case <-ctx.Done():
		return ctx.Err()
	default:
		p := aws.ToString(r.Prompt)

		s3Response, err := s3cli.GetObjectBody(ctx, p, promptBucketName)
		if err != nil {
			return errors.Join(ErrorGetBucketFileContent(p, promptBucketName), err)
		}
		defer s3Response.Close()

		r.promptBuf.Reset()
		if err = utils.TemplateFromReaderToWriter(r.promptBuf, s3Response, r); err != nil {
			return errors.Join(ErrorParseTemplate(p), err)
		}
		return nil
	}
}

// Clone object (only primitives).
func (r *RequestDictionaryCraft) Clone() *RequestDictionaryCraft {
	clone := NewRequestDictionaryCraft()

	if r.Prompt != nil {
		prompt := *r.Prompt
		clone.Prompt = &prompt
	}
	if r.Model != nil {
		model := *r.Model
		clone.Model = &model
	}
	if r.DictionaryFile != nil {
		file := *r.DictionaryFile
		clone.DictionaryFile = &file
	}
	if r.DictionaryTopic != nil {
		topic := *r.DictionaryTopic
		clone.DictionaryTopic = &topic
	}
	if r.DictionaryDescription != nil {
		desc := *r.DictionaryDescription
		clone.DictionaryDescription = &desc
	}
	if r.LanguageLevel != nil {
		level := *r.LanguageLevel
		clone.LanguageLevel = &level
	}
	if r.LanguageFrom != nil {
		from := *r.LanguageFrom
		clone.LanguageFrom = &from
	}
	if r.LanguageTo != nil {
		to := *r.LanguageTo
		clone.LanguageTo = &to
	}

	clone.Temperature = r.Temperature
	clone.WordsCount = r.WordsCount
	return clone
}
